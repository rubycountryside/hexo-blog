<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>RubyCountryside</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="记录一点一滴的生活">
<meta property="og:type" content="website">
<meta property="og:title" content="RubyCountryside">
<meta property="og:url" content="http://RubyCountryside.win/index.html">
<meta property="og:site_name" content="RubyCountryside">
<meta property="og:description" content="记录一点一滴的生活">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="RubyCountryside">
<meta name="twitter:description" content="记录一点一滴的生活">
  
    <link rel="alternate" href="/atom.xml" title="RubyCountryside" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">RubyCountryside</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://RubyCountryside.win"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-git分支" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/01/15/git分支/" class="article-date">
  <time datetime="2017-01-15T15:20:55.000Z" itemprop="datePublished">2017-01-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/01/15/git分支/">git分支</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ol>
<li><p>创建分支： $ git branch mybranch<br>$ git push –set-upstream origin ljz-v1.0.0-2<br>注意：在前一个分支的基础上创建新分支</p>
</li>
<li><p>切换分支： $ git checkout mybranch</p>
</li>
<li><p>创建并切换分支： $ git checkout -b mybranch</p>
</li>
<li><p>更新分支：$git rebase master<br>把master分支的内容更新到当前分支，打补丁<br><a href="http://blog.csdn.net/hudashi/article/details/7664631/" target="_blank" rel="external">http://blog.csdn.net/hudashi/article/details/7664631/</a><br><a href="http://blog.csdn.net/wh_19910525/article/details/7554489" target="_blank" rel="external">http://blog.csdn.net/wh_19910525/article/details/7554489</a></p>
</li>
<li><p>合并分支：<br>$ git merge mybranch<br>$ git  push origin current_branch<br>把mybranch的commits合并到当前分支上，mybranch仍然存在，</p>
</li>
</ol>
<ol>
<li><p>删除分支： $ git branch -d mybranch<br>强制删除分支： $ git branch -D mybranch<br>删除远程分支：git push origin :mybranch(不能删除master)</p>
</li>
<li><p>列出所有分支： $ git branch<br>列出远程分支：$ git branch -r<br>列出本地分支：$ git branch -l<br>列出全部分支：$ git branch -a</p>
</li>
<li><p>关联分支：<br>git branch –set-upstream mybranch origin/mybranch<br>git branch –unset-upstream mybranch origin/mybranch</p>
</li>
</ol>
<ol>
<li><p>克隆指定分支<br>$ git clone -b mybranch <a href="http://github.com/SapphireCastle/test-repo" target="_blank" rel="external">http://github.com/SapphireCastle/test-repo</a></p>
</li>
<li><p>推送分支<br>$ git push origin mybranch 创建或更新分支</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://RubyCountryside.win/2017/01/15/git分支/" data-id="cixytbaob0002ewz0xr8wixiy" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-图片滤镜操作" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/01/12/图片滤镜操作/" class="article-date">
  <time datetime="2017-01-12T02:13:47.000Z" itemprop="datePublished">2017-01-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/01/12/图片滤镜操作/">图片滤镜操作</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="1-灰度调整"><a href="#1-灰度调整" class="headerlink" title="1.灰度调整"></a>1.灰度调整</h3><p> 将彩色图像转化成为灰度图像的过程成为图像的灰度化处理。彩色图像中的每个像素的颜色有R、G、B三个分量决定，而每个分量有255中值可取，这样一个像素点可以有1600多万（255<em>255</em>255）的颜色的变化范围。而灰度图像是R、G、B三个分量相同的一种特殊的彩色图像，其一个像素点的变化范围为255种，所以在数字图像处理种一般先将各种格式的图像转变成灰度图像以使后续的图像的计算量变得少一些。灰度图像的描述与彩色图像一样仍然反映了整幅图像的整体和局部的色度和亮度等级的分布和特征。图像的灰度化处理可用两种方法来实现。</p>
<p>第一种方法使求出每个像素点的R、G、B三个分量的平均值，然后将这个平均值赋予给这个像素的三个分量。</p>
<p>第二种方法是根据YUV的颜色空间中，Y的分量的物理意义是点的亮度，由该值反映亮度等级，根据RGB和YUV颜色空间的变化关系可建立亮度Y与R、G、B三个颜色分量的对应：Y=0.3R+0.59G+0.11B，以这个亮度值表达图像的灰度值。</p>
<h3 id="2-亮度调整"><a href="#2-亮度调整" class="headerlink" title="2.亮度调整"></a>2.亮度调整</h3><p>   亮度（Brightness或者intensity）是颜色的相对明暗程度，通常使用从0%（黑色）至100%（白色）的百分比来度量.<br>   图像的色调通常是指图像的整体明暗度，例如，如果图像亮部像素较多的话，则图像整体上看起来较为明快。反之，如果图像中暗部像素较多的话，则图像整体上看起来较为昏暗。对于彩色图像而言，图像具有多个色调。通过调整不同颜色通道的色调，可对图像进行细微的调整。</p>
<h3 id="3-半透明度调整"><a href="#3-半透明度调整" class="headerlink" title="3.半透明度调整"></a>3.半透明度调整</h3><pre><code>根据图像grba直接调整透明度的值。
</code></pre><h3 id="4-模糊"><a href="#4-模糊" class="headerlink" title="4.模糊"></a>4.模糊</h3><pre><code>图像中的像素每一个都有自己的像素值，这些像素值决定了图像最终的显示。来想象一幅模糊的图，是不是感觉越模糊，这些像素点之间的差别就越小呢？确实是这样，这也是图像模糊的原理，也就是一种像素的平滑化，通过对图像中的像素值进行平均处理，让这些像素值越来越来接近，来达到一种人尽量无法辨识出这些像素点的差别，从来产生模糊的效果。减小rgb三个像素点的值，具体代码如下:

    var idx2 = (colOff + rowOff * tempCanvasData.width) * 4; 
    var r = tempCanvasData.data[idx2 + 0]; 
    var g = tempCanvasData.data[idx2 + 1]; 
    var b = tempCanvasData.data[idx2 + 2]; 
    sumred += r; 
    sumgreen += g; 
    sumblue += b; 
    } 
    } 
    var nr = (sumred / 25.0); 
    var ng = (sumgreen / 25.0); 
    var nb = (sumblue / 25.0); 

    sumred = 0.0; 
    sumgreen = 0.0; 
    sumblue = 0.0; 

    canvasData.data[idx + 0] = nr; // Red channel 
    canvasData.data[idx + 1] = ng; // Green channel 
    canvasData.data[idx + 2] = nb; // Blue channel 
    canvasData.data[idx + 3] = 255; // Alpha channel 
    } 
    }
</code></pre><h3 id="5-浮雕"><a href="#5-浮雕" class="headerlink" title="5.浮雕"></a>5.浮雕</h3><p>利用卷积公式，实现图像浮雕效果的一般原理是，将图像上每个像素点与其对角线的像素点形成差值，使相似颜色值淡化，不同颜色值突出，从而产生纵深感，达到浮雕的效果，具体的做法是取主对角线除右下角外的各点之和的平均值，减去右下角点的值，再加上填充背景色，再加上一个背景常数，一般为128而成，会形成类似浮雕的效果<br>fudiaoProcess:function (c,canvasData) {<br>var tempCanvasData = this.copyImageData(c, canvasData);<br>for ( var x = 1; x &lt; tempCanvasData.width-1; x++)<br>{<br>for ( var y = 1; y &lt; tempCanvasData.height-1; y++)<br>{<br>// Index of the pixel in the array<br>var idx = (x + y <em> tempCanvasData.width) </em> 4;<br>var bidx = ((x-1) + y <em> tempCanvasData.width) </em> 4;<br>var aidx = ((x+1) + y <em> tempCanvasData.width) </em> 4;<br>// calculate new RGB value<br>var nr = tempCanvasData.data[aidx + 0] - tempCanvasData.data[bidx + 0] + 128;<br>var ng = tempCanvasData.data[aidx + 1] - tempCanvasData.data[bidx + 1] + 128;<br>var nb = tempCanvasData.data[aidx + 2] - tempCanvasData.data[bidx + 2] + 128;<br>nr = (nr &lt; 0) ? 0 : ((nr &gt;255) ? 255 : nr);<br>ng = (ng &lt; 0) ? 0 : ((ng &gt;255) ? 255 : ng);<br>nb = (nb &lt; 0) ? 0 : ((nb &gt;255) ? 255 : nb);<br>// assign new pixel value<br>canvasData.data[idx + 0] = nr; // Red channel<br>canvasData.data[idx + 1] = ng; // Green channel<br>canvasData.data[idx + 2] = nb; // Blue channel<br>canvasData.data[idx + 3] = 255; // Alpha channel<br>}<br>}<br>},</p>
<h3 id="6-雕刻"><a href="#6-雕刻" class="headerlink" title="6.雕刻"></a>6.雕刻</h3><p>雕刻原理几乎相近，也是利用卷积公式，代码实现稍有差别<br>var nr = tempCanvasData.data[bidx + 0] - tempCanvasData.data[aidx + 0] + 128;<br>var ng = tempCanvasData.data[bidx + 1] - tempCanvasData.data[aidx + 1] + 128;<br>var nb = tempCanvasData.data[bidx + 2] - tempCanvasData.data[aidx + 2] + 128; </p>
<h3 id="7-反色"><a href="#7-反色" class="headerlink" title="7.反色"></a>7.反色</h3><p>对于彩色图像的R、G、B各彩色分量取反的技术就是图像的反色处理，这在处理二值化图像的连通区域选取的时候非常重要。如物体连通域用黑色表示，而二值化后的物体连通域图像可那是白色的，而背景是黑色的，这时应手动选取图像的反色处理或有程序根据背景和物体连通域两种颜色的数量所占比例而自动选择是否选择选取图像的反色处理。</p>
<h3 id="8-滤镜"><a href="#8-滤镜" class="headerlink" title="8.滤镜"></a>8.滤镜</h3><p>本例已红色滤镜实现为例<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span>(binaryData, l) &#123; </div><div class="line">	<span class="keyword">for</span> (var i = 0; i &lt; l; i += 4) &#123;</div><div class="line">		</div><div class="line">		var r = binaryData[i]; </div><div class="line">		var g = binaryData[i + 1]; </div><div class="line">		var b = binaryData[i + 2]; </div><div class="line">		binaryData[i] = (r + g + b)/3; </div><div class="line">		binaryData[i + 1] = 0; </div><div class="line">		binaryData[i + 2] = 0; </div><div class="line">		&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://RubyCountryside.win/2017/01/12/图片滤镜操作/" data-id="cixytbaoh0006ewz03pnsoxu3" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-图片画廊" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/01/11/图片画廊/" class="article-date">
  <time datetime="2017-01-11T12:29:36.000Z" itemprop="datePublished">2017-01-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/01/11/图片画廊/">图片画廊</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><ol>
<li><p>根据滑动条移动调整图片比例</p>
<h4 id="html代码展示"><a href="#html代码展示" class="headerlink" title="html代码展示"></a>html代码展示</h4> <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;div class=<span class="string">"top"</span>&gt;</div><div class="line">	&lt;h2&gt;永恒之画&lt;/h2&gt;</div><div class="line">	&lt;div class=<span class="string">"photoRange"</span>&gt;&lt;input <span class="built_in">type</span>=<span class="string">"range"</span> min=<span class="string">"50"</span> max=<span class="string">"150"</span> class=<span class="string">"inputRange"</span> id=<span class="string">"rangeImg"</span>&gt;&lt;/div&gt;			</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
<h4 id="js代码展示"><a href="#js代码展示" class="headerlink" title="js代码展示"></a>js代码展示</h4> <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$valRange</span> = $(<span class="string">"#rangeImg"</span>);</div><div class="line">   <span class="variable">$photo</span> = $(<span class="string">"#bgImg"</span>);</div><div class="line">   <span class="variable">$phtWidth</span> = <span class="variable">$photo</span>.width();</div><div class="line">   <span class="variable">$phtHeight</span> = <span class="variable">$photo</span>.height();</div><div class="line">   <span class="variable">$valRange</span>.mousemove(<span class="keyword">function</span>(e)&#123;</div><div class="line">       var ratio = this.value / 100;</div><div class="line">       console.log(ratio);</div><div class="line">       <span class="variable">$photo</span>.css(<span class="string">"width"</span>, <span class="variable">$phtWidth</span> * ratio);</div><div class="line">       <span class="variable">$photo</span>.css(<span class="string">"height"</span>, <span class="variable">$phtHeight</span> * ratio);</div><div class="line">   &#125;);</div></pre></td></tr></table></figure>
</li>
<li><p>对图片元素增加鼠标点击事件，用到mousedown,mouseup,mousemove。实现的效果：在图片上按下鼠标，<br>出发mousedown事件，然后在图片上绑定mousemove事件，图片可以随着鼠标移动位置发生改变。当鼠标弹起，<br>即出发mouseup事件，当发生mouseup事件时，立即解绑mousemove事件。</p>
<h4 id="js实现的代码如下"><a href="#js实现的代码如下" class="headerlink" title="js实现的代码如下:"></a>js实现的代码如下:</h4> <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var mousex = 0, mousey = 0;</div><div class="line">   var divLeft, divTop;</div><div class="line">   $(<span class="string">'#bgImg'</span>).mousedown(<span class="keyword">function</span>(e)</div><div class="line">   &#123;</div><div class="line">       var offset = $(this).offset();</div><div class="line">       divLeft = parseInt(offset.left,10);</div><div class="line">       divTop = parseInt(offset.top,10);</div><div class="line">       mousey = e.pageY;</div><div class="line">       mousex = e.pageX;</div><div class="line">       $(this).bind(<span class="string">'mousemove'</span>,dragElement);</div><div class="line">   &#125;);</div></pre></td></tr></table></figure>
<p> 2.1 图片移动时用到的知识<br> clientX<br> offset()<br> animation<br> stop()</p>
<h3 id="拓展点"><a href="#拓展点" class="headerlink" title="拓展点"></a>拓展点</h3><pre><code>clientX 设置或获取鼠标指针位置相对于窗口客户区域的 x 坐标，其中客户区域不包括窗口自身的控件和滚动条。 
clientY 设置或获取鼠标指针位置相对于窗口客户区域的 y 坐标，其中客户区域不包括窗口自身的控件和滚动条。 
offsetX 设置或获取鼠标指针位置相对于触发事件的对象的 x 坐标。 
offsetY 设置或获取鼠标指针位置相对于触发事件的对象的 y 坐标。 
screenX 设置或获取获取鼠标指针位置相对于用户屏幕的 x 坐标。 
screenY 设置或获取鼠标指针位置相对于用户屏幕的 y 坐标。 
x 设置或获取鼠标指针位置相对于父文档的 x 像素坐标。 
y 设置或获取鼠标指针位置相对于父文档的 y 像素坐标。
</code></pre><p>3.css3新属性</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">.box-shadow</div><div class="line">.appearance /* 取消浏览器默认样式 */ 主要用在美化滑块控件上面</div></pre></td></tr></table></figure></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://RubyCountryside.win/2017/01/11/图片画廊/" data-id="cixytbaol0008ewz0ug9ztw26" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-函数中" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/01/11/函数中/" class="article-date">
  <time datetime="2017-01-10T16:24:32.000Z" itemprop="datePublished">2017-01-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/01/11/函数中/">函数（中）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>（3）callee属性</p>
<p>arguments对象带有一个callee属性，返回它所对应的原函数。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var f = <span class="keyword">function</span>(one) &#123;</div><div class="line">  console.log(arguments.callee === f);</div><div class="line">&#125;</div><div class="line"></div><div class="line">f() // <span class="literal">true</span></div></pre></td></tr></table></figure></p>
<p>可以通过arguments.callee，达到调用函数自身的目的。这个属性在严格模式里面是禁用的，因此不建议使用。</p>
<p>函数的其他知识点<br>闭包</p>
<p>闭包（closure）是Javascript语言的一个难点，也是它的特色，很多高级应用都要依靠闭包实现。</p>
<p>要理解闭包，首先必须理解变量作用域。前面提到，JavaScript有两种作用域：全局作用域和函数作用域。函数内部可以直接读取全局变量。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var n = 999;</div><div class="line"></div><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">f1</span></span>() &#123;</div><div class="line">  console.log(n);</div><div class="line">&#125;</div><div class="line">f1() // 999</div></pre></td></tr></table></figure></p>
<p>上面代码中，函数f1可以读取全局变量n。</p>
<p>但是，在函数外部无法读取函数内部声明的变量。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">f1</span></span>() &#123;</div><div class="line">  var n = 999;</div><div class="line">&#125;</div><div class="line"></div><div class="line">console.log(n)</div><div class="line">// Uncaught ReferenceError: n is not defined</div></pre></td></tr></table></figure></p>
<p>上面代码中，函数f1内部声明的变量n，函数外是无法读取的。</p>
<p>如果出于种种原因，需要得到函数内的局部变量。正常情况下，这是办不到的，只有通过变通方法才能实现。那就是在函数的内部，再定义一个函数。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">f1</span></span>() &#123;</div><div class="line">  var n = 999;</div><div class="line">  <span class="keyword">function</span> <span class="function"><span class="title">f2</span></span>() &#123;</div><div class="line">　　console.log(n); // 999</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面代码中，函数f2就在函数f1内部，这时f1内部的所有局部变量，对f2都是可见的。但是反过来就不行，f2内部的局部变量，对f1就是不可见的。这就是JavaScript语言特有的”链式作用域”结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。</p>
<p>既然f2可以读取f1的局部变量，那么只要把f2作为返回值，我们不就可以在f1外部读取它的内部变量了吗！<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">f1</span></span>() &#123;</div><div class="line">  var n = 999;</div><div class="line">  <span class="keyword">function</span> <span class="function"><span class="title">f2</span></span>() &#123;</div><div class="line">    console.log(n);</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">return</span> f2;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var result = f1();</div><div class="line">result(); // 999</div></pre></td></tr></table></figure></p>
<p>上面代码中，函数f1的返回值就是函数f2，由于f2可以读取f1的内部变量，所以就可以在外部获得f1的内部变量了。</p>
<p>闭包就是函数f2，即能够读取其他函数内部变量的函数。由于在JavaScript语言中，只有函数内部的子函数才能读取内部变量，因此可以把闭包简单理解成“定义在一个函数内部的函数”。闭包最大的特点，就是它可以“记住”诞生的环境，比如f2记住了它诞生的环境f1，所以从f2可以得到f1的内部变量。在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。</p>
<p>闭包的最大用处有两个，一个是可以读取函数内部的变量，另一个就是让这些变量始终保持在内存中，即闭包可以使得它诞生环境一直存在。请看下面的例子，闭包使得内部变量记住上一次调用时的运算结果。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> createIncrementor(start) &#123;</div><div class="line">  <span class="built_in">return</span> <span class="function"><span class="title">function</span></span> () &#123;</div><div class="line">    <span class="built_in">return</span> start++;</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var inc = createIncrementor(5);</div><div class="line"></div><div class="line">inc() // 5</div><div class="line">inc() // 6</div><div class="line">inc() // 7</div></pre></td></tr></table></figure></p>
<p>上面代码中，start是函数createIncrementor的内部变量。通过闭包，start的状态被保留了，每一次调用都是在上一次调用的基础上进行计算。从中可以看到，闭包inc使得函数createIncrementor的内部环境，一直存在。所以，闭包可以看作是函数内部作用域的一个接口。</p>
<p>为什么会这样呢？原因就在于inc始终在内存中，而inc的存在依赖于createIncrementor，因此也始终在内存中，不会在调用结束后，被垃圾回收机制回收。</p>
<p>闭包的另一个用处，是封装对象的私有属性和私有方法。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> Person(name) &#123;</div><div class="line">  var _age;</div><div class="line">  <span class="keyword">function</span> <span class="built_in">set</span>Age(n) &#123;</div><div class="line">    _age = n;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">function</span> <span class="function"><span class="title">getAge</span></span>() &#123;</div><div class="line">    <span class="built_in">return</span> _age;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="built_in">return</span> &#123;</div><div class="line">    name: name,</div><div class="line">    getAge: getAge,</div><div class="line">    <span class="built_in">set</span>Age: <span class="built_in">set</span>Age</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var p1 = Person(<span class="string">'张三'</span>);</div><div class="line">p1.setAge(25);</div><div class="line">p1.getAge() // 25</div></pre></td></tr></table></figure></p>
<p>上面代码中，函数Person的内部变量_age，通过闭包getAge和setAge，变成了返回对象p1的私有变量。</p>
<p>注意，外层函数每次运行，都会生成一个新的闭包，而这个闭包又会保留外层函数的内部变量，所以内存消耗很大。因此不能滥用闭包，否则会造成网页的性能问题。</p>
<p>立即调用的函数表达式（IIFE）</p>
<p>在Javascript中，一对圆括号()是一种运算符，跟在函数名之后，表示调用该函数。比如，print()就表示调用print函数。</p>
<p>有时，我们需要在定义函数之后，立即调用该函数。这时，你不能在函数的定义之后加上圆括号，这会产生语法错误。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">function</span></span>()&#123; /* code */ &#125;();</div><div class="line">// SyntaxError: Unexpected token (</div><div class="line">产生这个错误的原因是，<span class="keyword">function</span>这个关键字即可以当作语句，也可以当作表达式。</div><div class="line"></div><div class="line">// 语句</div><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;&#125;</div><div class="line"></div><div class="line">// 表达式</div><div class="line">var f = <span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;&#125;</div><div class="line">为了避免解析上的歧义，JavaScript引擎规定，如果<span class="keyword">function</span>关键字出现在行首，一律解释成语句。因此，JavaScript引擎看到行首是<span class="keyword">function</span>关键字之后，认为这一段都是函数的定义，不应该以圆括号结尾，所以就报错了。</div><div class="line"></div><div class="line">解决方法就是不要让<span class="keyword">function</span>出现在行首，让引擎将其理解成一个表达式。最简单的处理，就是将其放在一个圆括号里面。</div></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="title">function</span></span>()&#123; /* code */ &#125;());</div><div class="line">// 或者</div><div class="line">(<span class="function"><span class="title">function</span></span>()&#123; /* code */ &#125;)();</div></pre></td></tr></table></figure>
<p>上面两种写法都是以圆括号开头，引擎就会认为后面跟的是一个表示式，而不是函数定义语句，所以就避免了错误。这就叫做“立即调用的函数表达式”（Immediately-Invoked Function Expression），简称IIFE。</p>
<p>注意，上面两种写法最后的分号都是必须的。如果省略分号，遇到连着两个IIFE，可能就会报错。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// 报错</div><div class="line">(<span class="function"><span class="title">function</span></span>()&#123; /* code */ &#125;())</div><div class="line">(<span class="function"><span class="title">function</span></span>()&#123; /* code */ &#125;())</div></pre></td></tr></table></figure></p>
<p>上面代码的两行之间没有分号，JavaScript会将它们连在一起解释，将第二行解释为第一行的参数。</p>
<p>推而广之，任何让解释器以表达式来处理函数定义的方法，都能产生同样的效果，比如下面三种写法。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">var i = <span class="function"><span class="title">function</span></span>()&#123; <span class="built_in">return</span> 10; &#125;();</div><div class="line"><span class="literal">true</span> &amp;&amp; <span class="function"><span class="title">function</span></span>()&#123; /* code */ &#125;();</div><div class="line">0, <span class="function"><span class="title">function</span></span>()&#123; /* code */ &#125;();</div><div class="line">甚至像下面这样写，也是可以的。</div><div class="line"></div><div class="line">!<span class="function"><span class="title">function</span></span>()&#123; /* code */ &#125;();</div><div class="line">~<span class="function"><span class="title">function</span></span>()&#123; /* code */ &#125;();</div><div class="line">-<span class="function"><span class="title">function</span></span>()&#123; /* code */ &#125;();</div><div class="line">+<span class="function"><span class="title">function</span></span>()&#123; /* code */ &#125;();</div><div class="line">new关键字也能达到这个效果。</div><div class="line"></div><div class="line">new <span class="function"><span class="title">function</span></span>()&#123; /* code */ &#125;</div><div class="line"></div><div class="line">new <span class="function"><span class="title">function</span></span>()&#123; /* code */ &#125;()</div></pre></td></tr></table></figure></p>
<p>// 只有传递参数时，才需要最后那个圆括号<br>通常情况下，只对匿名函数使用这种“立即执行的函数表达式”。它的目的有两个：一是不必为函数命名，避免了污染全局变量；二是IIFE内部形成了一个单独的作用域，可以封装一些外部无法读取的私有变量。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// 写法一</div><div class="line">var tmp = newData;</div><div class="line">processData(tmp);</div><div class="line">storeData(tmp);</div><div class="line"></div><div class="line">// 写法二</div><div class="line">(<span class="function"><span class="title">function</span></span> ()&#123;</div><div class="line">  var tmp = newData;</div><div class="line">  processData(tmp);</div><div class="line">  storeData(tmp);</div><div class="line">&#125;());</div></pre></td></tr></table></figure></p>
<p>上面代码中，写法二比写法一更好，因为完全避免了污染全局变量。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://RubyCountryside.win/2017/01/11/函数中/" data-id="cixytbaoe0005ewz0395z6xmp" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-函数下" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/01/10/函数下/" class="article-date">
  <time datetime="2017-01-10T15:41:15.000Z" itemprop="datePublished">2017-01-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/01/10/函数下/">函数（下）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">概述</div><div class="line">  函数的声明</div><div class="line">  函数的重复声明</div><div class="line">  圆括号运算符，<span class="built_in">return</span>语句和递归</div><div class="line">  第一等公民</div><div class="line">  函数名的提升</div><div class="line">  不能在条件语句中声明函数</div><div class="line">函数的属性和方法</div><div class="line">  name属性</div><div class="line">  length属性</div><div class="line">  toString()</div><div class="line">函数作用域</div><div class="line">定义</div><div class="line">函数内部的变量提升</div><div class="line">函数本身的作用域</div><div class="line">参数</div><div class="line">概述</div><div class="line">参数的省略</div><div class="line">默认值</div><div class="line">传递方式</div><div class="line">同名参数</div><div class="line">arguments对象</div><div class="line">函数的其他知识点</div><div class="line">闭包</div><div class="line">立即调用的函数表达式（IIFE）</div><div class="line"><span class="built_in">eval</span>命令</div></pre></td></tr></table></figure>
<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><hr>
<h3 id="1-1-函数的声明"><a href="#1-1-函数的声明" class="headerlink" title="1.1 函数的声明"></a>1.1 函数的声明</h3><p>（1）function 命令<br>function命令声明的代码区块，就是一个函数。function命令后面是函数名，函数名后面是一对圆括号，里面是传入函数的参数。函数体放在大括号里面。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> <span class="built_in">print</span>(s) &#123;</div><div class="line">  console.log(s);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面的代码命名了一个print函数，以后使用print()这种形式，就可以调用相应的代码。这叫做函数的声明（Function Declaration）</p>
<h3 id="（2）函数表达式"><a href="#（2）函数表达式" class="headerlink" title="（2）函数表达式"></a>（2）函数表达式</h3><p>除了用function命令声明函数，还可以采用变量赋值的写法<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var <span class="built_in">print</span> = <span class="keyword">function</span>(s) &#123;</div><div class="line">  console.log(s);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>这种写法将一个匿名函数赋值给变量。这时，这个匿名函数又称函数表达式（Function Expression），因为赋值语句的等号右侧只能放表达式。<br>采用函数表达式声明函数时，function命令后面不带有函数名。如果加上函数名，该函数名只在函数体内部有效，在函数体外部无效。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var <span class="built_in">print</span> = <span class="keyword">function</span> <span class="function"><span class="title">x</span></span>()&#123;</div><div class="line">  console.log(typeof x);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">x</div><div class="line">// ReferenceError: x is not defined</div><div class="line"></div><div class="line"><span class="built_in">print</span>()</div><div class="line">// <span class="keyword">function</span></div></pre></td></tr></table></figure></p>
<p>上面代码在函数表达式中，加入了函数名x。这个x只在函数体内部可用，指代函数表达式本身，其他地方都不可用。这种写法的用处有两个，一是可以在函数体内部调用自身，二是方便除错（除错工具显示函数调用栈时，将显示函数名，而不再显示这里是一个匿名函数）。因此，下面的形式声明函数也非常常见。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var f = <span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;&#125;;</div></pre></td></tr></table></figure></p>
<p>（3）Function构造函数</p>
<p>还有第三种声明函数的方式：Function构造函数。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var add = new Function(</div><div class="line">  <span class="string">'x'</span>,</div><div class="line">  <span class="string">'y'</span>,</div><div class="line">  <span class="string">'return x + y'</span></div><div class="line">);</div><div class="line"></div><div class="line">// 等同于</div><div class="line"></div><div class="line"><span class="keyword">function</span> add(x, y) &#123;</div><div class="line">  <span class="built_in">return</span> x + y;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="1-2-函数名的提升"><a href="#1-2-函数名的提升" class="headerlink" title="1.2 函数名的提升"></a>1.2 函数名的提升</h3><p>JavaScript引擎将函数名视同变量名，所以采用function命令声明函数时，整个函数会像变量声明一样，被提升到代码头部。所以，下面的代码不会报错。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">f();</div><div class="line"></div><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;&#125;</div></pre></td></tr></table></figure></p>
<p>表面上，上面代码好像在声明之前就调用了函数f。但是实际上，由于“变量提升”，函数f被提升到了代码头部，也就是在调用之前已经声明了。但是，如果采用赋值语句定义函数，JavaScript就会报错。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">f();</div><div class="line">var f = <span class="function"><span class="title">function</span></span> ()&#123;&#125;;</div><div class="line">// TypeError: undefined is not a <span class="keyword">function</span></div></pre></td></tr></table></figure></p>
<p>上面的代码等同于下面的形式。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var f;</div><div class="line">f();</div><div class="line">f = <span class="function"><span class="title">function</span></span> () &#123;&#125;;</div></pre></td></tr></table></figure></p>
<p>上面代码第二行，调用f的时候，f只是被声明了，还没有被赋值，等于undefined，所以会报错。因此，如果同时采用function命令和赋值语句声明同一个函数，最后总是采用赋值语句的定义。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var f = <span class="function"><span class="title">function</span></span>() &#123;</div><div class="line">  console.log(<span class="string">'1'</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;</div><div class="line">  console.log(<span class="string">'2'</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">f() // 1</div></pre></td></tr></table></figure></p>
<p>不能在条件语句中声明函数</p>
<p>根据ECMAScript的规范，不得在非函数的代码块中声明函数，最常见的情况就是if和try语句。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (foo) &#123;</div><div class="line">  <span class="keyword">function</span> <span class="function"><span class="title">x</span></span>() &#123;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">try &#123;</div><div class="line">  <span class="keyword">function</span> <span class="function"><span class="title">x</span></span>() &#123;&#125;</div><div class="line">&#125; catch(e) &#123;</div><div class="line">  console.log(e);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面代码分别在if代码块和try代码块中声明了两个函数，按照语言规范，这是不合法的。但是，实际情况是各家浏览器往往并不报错，能够运行。</p>
<p>但是由于存在函数名的提升，所以在条件语句中声明函数，可能是无效的，这是非常容易出错的地方。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (<span class="literal">false</span>) &#123;</div><div class="line">  <span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">f() // 不报错</div></pre></td></tr></table></figure></p>
<p>上面代码的原始意图是不声明函数f，但是由于f的提升，导致if语句无效，所以上面的代码不会报错。要达到在条件语句中定义函数的目的，只有使用函数表达式。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (<span class="literal">false</span>) &#123;</div><div class="line">  var f = <span class="function"><span class="title">function</span></span> () &#123;&#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">f() // undefined</div></pre></td></tr></table></figure></p>
<p>函数的属性和方法<br>name属性</p>
<p>name属性返回紧跟在function关键字之后的那个函数名。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">f1</span></span>() &#123;&#125;</div><div class="line">f1.name // <span class="string">'f1'</span></div><div class="line"></div><div class="line">var f2 = <span class="function"><span class="title">function</span></span> () &#123;&#125;;</div><div class="line">f2.name // <span class="string">''</span></div><div class="line"></div><div class="line">var f3 = <span class="keyword">function</span> <span class="function"><span class="title">myName</span></span>() &#123;&#125;;</div><div class="line">f3.name // <span class="string">'myName'</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，函数的name属性总是返回紧跟在function关键字之后的那个函数名。对于f2来说，返回空字符串，匿名函数的name属性总是为空字符串；对于f3来说，返回函数表达式的名字（真正的函数名还是f3，myName这个名字只在函数体内部可用）。</p>
<p>length属性</p>
<p>length属性返回函数预期传入的参数个数，即函数定义之中的参数个数。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> f(a, b) &#123;&#125;</div><div class="line">f.length // 2</div></pre></td></tr></table></figure></p>
<p>上面代码定义了空函数f，它的length属性就是定义时的参数个数。不管调用时输入了多少个参数，length属性始终等于2。</p>
<p>length属性提供了一种机制，判断定义时和调用时参数的差异，以便实现面向对象编程的”方法重载“（overload）。</p>
<p>toString()</p>
<p>函数的toString方法返回函数的源码。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;</div><div class="line">  a();</div><div class="line">  b();</div><div class="line">  c();</div><div class="line">&#125;</div><div class="line"></div><div class="line">f.toString()</div><div class="line">// <span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;</div><div class="line">//  a();</div><div class="line">//  b();</div><div class="line">//  c();</div><div class="line">// &#125;</div><div class="line">函数内部的注释也可以返回。</div><div class="line"></div><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;/*</div><div class="line">  这是一个</div><div class="line">  多行注释</div><div class="line">*/&#125;</div><div class="line"></div><div class="line">f.toString()</div><div class="line">// <span class="string">"function f()&#123;/*</span></div><div class="line">//   这是一个</div><div class="line">//   多行注释</div><div class="line">// */&#125;"</div><div class="line">利用这一点，可以变相实现多行字符串。</div><div class="line"></div><div class="line">var multiline = <span class="keyword">function</span> (fn) &#123;</div><div class="line">  var arr = fn.toString().split(<span class="string">'\n'</span>);</div><div class="line">  <span class="built_in">return</span> arr.slice(1, arr.length - 1).join(<span class="string">'\n'</span>);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;/*</div><div class="line">  这是一个</div><div class="line">  多行注释</div><div class="line">*/&#125;</div><div class="line"></div><div class="line">multiline(f);</div><div class="line">// <span class="string">" 这是一个</span></div><div class="line">//   多行注释"</div></pre></td></tr></table></figure></p>
<p>函数作用域<br>定义</p>
<p>作用域（scope）指的是变量存在的范围。Javascript只有两种作用域：一种是全局作用域，变量在整个程序中一直存在，所有地方都可以读取；另一种是函数作用域，变量只在函数内部存在。</p>
<p>在函数外部声明的变量就是全局变量（global variable），它可以在函数内部读取。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var v = 1;</div><div class="line"></div><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">f</span></span>()&#123;</div><div class="line">  console.log(v);</div><div class="line">&#125;</div><div class="line"></div><div class="line">f()</div><div class="line">// 1</div></pre></td></tr></table></figure></p>
<p>上面的代码表明，函数f内部可以读取全局变量v。</p>
<p>在函数内部定义的变量，外部无法读取，称为“局部变量”（local variable）。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">f</span></span>()&#123;</div><div class="line">  var v = 1;</div><div class="line">&#125;</div><div class="line"></div><div class="line">v // ReferenceError: v is not defined</div></pre></td></tr></table></figure></p>
<p>上面代码中，变量v在函数内部定义，所以是一个局部变量，函数之外就无法读取。</p>
<p>函数内部定义的变量，会在该作用域内覆盖同名全局变量。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var v = 1;</div><div class="line"></div><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">f</span></span>()&#123;</div><div class="line">  var v = 2;</div><div class="line">  console.log(v);</div><div class="line">&#125;</div><div class="line"></div><div class="line">f() // 2</div><div class="line">v // 1</div></pre></td></tr></table></figure></p>
<p>上面代码中，变量v同时在函数的外部和内部有定义。结果，在函数内部定义，局部变量v覆盖了全局变量v。</p>
<p>注意，对于var命令来说，局部变量只能在函数内部声明，在其他区块中声明，一律都是全局变量。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</div><div class="line">  var x = 5;</div><div class="line">&#125;</div><div class="line">console.log(x);  // 5</div></pre></td></tr></table></figure></p>
<p>上面代码中，变量x在条件判断区块之中声明，结果就是一个全局变量，可以在区块之外读取。</p>
<p>函数内部的变量提升</p>
<p>与全局作用域一样，函数作用域内部也会产生“变量提升”现象。var命令声明的变量，不管在什么位置，变量声明都会被提升到函数体的头部。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> foo(x) &#123;</div><div class="line">  <span class="keyword">if</span> (x &gt; 100) &#123;</div><div class="line">    var tmp = x - 100;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">上面的代码等同于</div><div class="line"></div><div class="line"><span class="keyword">function</span> foo(x) &#123;</div><div class="line">  var tmp;</div><div class="line">  <span class="keyword">if</span> (x &gt; 100) &#123;</div><div class="line">    tmp = x - 100;</div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>函数本身的作用域</p>
<p>函数本身也是一个值，也有自己的作用域。它的作用域与变量一样，就是其声明时所在的作用域，与其运行时所在的作用域无关。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var a = 1;</div><div class="line">var x = <span class="function"><span class="title">function</span></span> () &#123;</div><div class="line">  console.log(a);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;</div><div class="line">  var a = 2;</div><div class="line">  x();</div><div class="line">&#125;</div><div class="line"></div><div class="line">f() // 1</div></pre></td></tr></table></figure></p>
<p>上面代码中，函数x是在函数f的外部声明的，所以它的作用域绑定外层，内部变量a不会到函数f体内取值，所以输出1，而不是2。</p>
<p>总之，函数执行时所在的作用域，是定义时的作用域，而不是调用时所在的作用域。</p>
<p>很容易犯错的一点是，如果函数A调用函数B，却没考虑到函数B不会引用函数A的内部变量。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var x = <span class="function"><span class="title">function</span></span> () &#123;</div><div class="line">  console.log(a);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">function</span> y(f) &#123;</div><div class="line">  var a = 2;</div><div class="line">  f();</div><div class="line">&#125;</div><div class="line"></div><div class="line">y(x)</div><div class="line">// ReferenceError: a is not defined</div></pre></td></tr></table></figure></p>
<p>上面代码将函数x作为参数，传入函数y。但是，函数x是在函数y体外声明的，作用域绑定外层，因此找不到函数y的内部变量a，导致报错。</p>
<p>同样的，函数体内部声明的函数，作用域绑定函数体内部。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">foo</span></span>() &#123;</div><div class="line">  var x = 1;</div><div class="line">  <span class="keyword">function</span> <span class="function"><span class="title">bar</span></span>() &#123;</div><div class="line">    console.log(x);</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">return</span> bar;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var x = 2;</div><div class="line">var f = foo();</div><div class="line">f() // 1</div></pre></td></tr></table></figure></p>
<p>上面代码中，函数foo内部声明了一个函数bar，bar的作用域绑定foo。当我们在foo外部取出bar执行时，变量x指向的是foo内部的x，而不是foo外部的x。正是这种机制，构成了下文要讲解的“闭包”现象。</p>
<p>参数<br>概述</p>
<p>函数运行的时候，有时需要提供外部数据，不同的外部数据会得到不同的结果，这种外部数据就叫参数。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> square(x) &#123;</div><div class="line">  <span class="built_in">return</span> x * x;</div><div class="line">&#125;</div><div class="line"></div><div class="line">square(2) // 4</div><div class="line">square(3) // 9</div></pre></td></tr></table></figure></p>
<p>上式的x就是square函数的参数。每次运行的时候，需要提供这个值，否则得不到结果。</p>
<p>参数的省略</p>
<p>函数参数不是必需的，Javascript允许省略参数。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> f(a, b) &#123;</div><div class="line">  <span class="built_in">return</span> a;</div><div class="line">&#125;</div><div class="line"></div><div class="line">f(1, 2, 3) // 1</div><div class="line">f(1) // 1</div><div class="line">f() // undefined</div><div class="line"></div><div class="line">f.length // 2</div></pre></td></tr></table></figure></p>
<p>上面代码的函数f定义了两个参数，但是运行时无论提供多少个参数（或者不提供参数），JavaScript都不会报错。</p>
<p>被省略的参数的值就变为undefined。需要注意的是，函数的length属性与实际传入的参数个数无关，只反映函数预期传入的参数个数。</p>
<p>但是，没有办法只省略靠前的参数，而保留靠后的参数。如果一定要省略靠前的参数，只有显式传入undefined。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> f(a, b) &#123;</div><div class="line">  <span class="built_in">return</span> a;</div><div class="line">&#125;</div><div class="line"></div><div class="line">f( , 1) // SyntaxError: Unexpected token ,(…)</div><div class="line">f(undefined, 1) // undefined</div></pre></td></tr></table></figure></p>
<p>上面代码中，如果省略第一个参数，就会报错。</p>
<p>默认值</p>
<p>通过下面的方法，可以为函数的参数设置默认值。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> f(a)&#123;</div><div class="line">  a = a || 1;</div><div class="line">  <span class="built_in">return</span> a;</div><div class="line">&#125;</div><div class="line"></div><div class="line">f(<span class="string">''</span>) // 1</div><div class="line">f(0) // 1</div></pre></td></tr></table></figure></p>
<p>上面代码的||表示“或运算”，即如果a有值，则返回a，否则返回事先设定的默认值（上例为1）。</p>
<p>这种写法会对a进行一次布尔运算，只有为true时，才会返回a。可是，除了undefined以外，0、空字符、null等的布尔值也是false。也就是说，在上面的函数中，不能让a等于0或空字符串，否则在明明有参数的情况下，也会返回默认值。</p>
<p>为了避免这个问题，可以采用下面更精确的写法。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> f(a) &#123;</div><div class="line">  (a !== undefined &amp;&amp; a !== null) ? a = a : a = 1;</div><div class="line">  <span class="built_in">return</span> a;</div><div class="line">&#125;</div><div class="line"></div><div class="line">f() // 1</div><div class="line">f(<span class="string">''</span>) // <span class="string">""</span></div><div class="line">f(0) // 0</div></pre></td></tr></table></figure></p>
<p>上面代码中，函数f的参数是空字符或0，都不会触发参数的默认值。</p>
<p>传递方式</p>
<p>函数参数如果是原始类型的值（数值、字符串、布尔值），传递方式是传值传递（passes by value）。这意味着，在函数体内修改参数值，不会影响到函数外部。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var p = 2;</div><div class="line"></div><div class="line"><span class="keyword">function</span> f(p) &#123;</div><div class="line">  p = 3;</div><div class="line">&#125;</div><div class="line">f(p);</div><div class="line"></div><div class="line">p // 2</div></pre></td></tr></table></figure></p>
<p>上面代码中，变量p是一个原始类型的值，传入函数f的方式是传值传递。因此，在函数内部，p的值是原始值的拷贝，无论怎么修改，都不会影响到原始值。</p>
<p>但是，如果函数参数是复合类型的值（数组、对象、其他函数），传递方式是传址传递（pass by reference）。也就是说，传入函数的原始值的地址，因此在函数内部修改参数，将会影响到原始值。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var obj = &#123;p: 1&#125;;</div><div class="line"></div><div class="line"><span class="keyword">function</span> f(o) &#123;</div><div class="line">  o.p = 2;</div><div class="line">&#125;</div><div class="line">f(obj);</div><div class="line"></div><div class="line">obj.p // 2</div></pre></td></tr></table></figure></p>
<p>上面代码中，传入函数f的是参数对象obj的地址。因此，在函数内部修改obj的属性p，会影响到原始值。</p>
<p>注意，如果函数内部修改的，不是参数对象的某个属性，而是替换掉整个参数，这时不会影响到原始值。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var obj = [1, 2, 3];</div><div class="line"></div><div class="line"><span class="keyword">function</span> f(o)&#123;</div><div class="line">  o = [2, 3, 4];</div><div class="line">&#125;</div><div class="line">f(obj);</div><div class="line"></div><div class="line">obj // [1, 2, 3]</div></pre></td></tr></table></figure></p>
<p>上面代码中，在函数f内部，参数对象obj被整个替换成另一个值。这时不会影响到原始值。这是因为，形式参数（o）与实际参数obj存在一个赋值关系。</p>
<p>// 函数f内部<br>o = obj;<br>上面代码中，对o的修改都会反映在obj身上。但是，如果对o赋予一个新的值，就等于切断了o与obj的联系，导致此后的修改都不会影响到obj了。</p>
<p>某些情况下，如果需要对某个原始类型的变量，获取传址传递的效果，可以将它写成全局对象的属性。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var a = 1;</div><div class="line"></div><div class="line"><span class="keyword">function</span> f(p) &#123;</div><div class="line">  window[p] = 2;</div><div class="line">&#125;</div><div class="line">f(<span class="string">'a'</span>);</div><div class="line"></div><div class="line">a // 2</div></pre></td></tr></table></figure></p>
<p>上面代码中，变量a本来是传值传递，但是写成window对象的属性，就达到了传址传递的效果。</p>
<p>同名参数</p>
<p>如果有同名的参数，则取最后出现的那个值。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> f(a, a) &#123;</div><div class="line">  console.log(a);</div><div class="line">&#125;</div><div class="line"></div><div class="line">f(1, 2) // 2</div></pre></td></tr></table></figure></p>
<p>上面的函数f有两个参数，且参数名都是a。取值的时候，以后面的a为准。即使后面的a没有值或被省略，也是以其为准。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> f(a, a)&#123;</div><div class="line">  console.log(a);</div><div class="line">&#125;</div><div class="line"></div><div class="line">f(1) // undefined</div></pre></td></tr></table></figure></p>
<p>调用函数f的时候，没有提供第二个参数，a的取值就变成了undefined。这时，如果要获得第一个a的值，可以使用arguments对象。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> f(a, a)&#123;</div><div class="line">  console.log(arguments[0]);</div><div class="line">&#125;</div><div class="line"></div><div class="line">f(1) // 1</div></pre></td></tr></table></figure></p>
<p>arguments对象</p>
<p>（1）定义</p>
<p>由于JavaScript允许函数有不定数目的参数，所以我们需要一种机制，可以在函数体内部读取所有参数。这就是arguments对象的由来。</p>
<p>arguments对象包含了函数运行时的所有参数，arguments[0]就是第一个参数，arguments[1]就是第二个参数，以此类推。这个对象只有在函数体内部，才可以使用。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">var f = <span class="keyword">function</span>(one) &#123;</div><div class="line">  console.log(arguments[0]);</div><div class="line">  console.log(arguments[1]);</div><div class="line">  console.log(arguments[2]);</div><div class="line">&#125;</div><div class="line"></div><div class="line">f(1, 2, 3)</div><div class="line">// 1</div><div class="line">// 2</div><div class="line">// 3</div><div class="line">arguments对象除了可以读取参数，还可以为参数赋值（严格模式不允许这种用法）。</div><div class="line"></div><div class="line">var f = <span class="keyword">function</span>(a, b) &#123;</div><div class="line">  arguments[0] = 3;</div><div class="line">  arguments[1] = 2;</div><div class="line">  <span class="built_in">return</span> a + b;</div><div class="line">&#125;</div><div class="line"></div><div class="line">f(1, 1)</div><div class="line">// 5</div><div class="line">可以通过arguments对象的length属性，判断函数调用时到底带几个参数。</div><div class="line"></div><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;</div><div class="line">  <span class="built_in">return</span> arguments.length;</div><div class="line">&#125;</div><div class="line"></div><div class="line">f(1, 2, 3) // 3</div><div class="line">f(1) // 1</div><div class="line">f() // 0</div></pre></td></tr></table></figure></p>
<p>（2）与数组的关系</p>
<p>需要注意的是，虽然arguments很像数组，但它是一个对象。数组专有的方法（比如slice和forEach），不能在arguments对象上直接使用。</p>
<p>但是，可以通过apply方法，把arguments作为参数传进去，这样就可以让arguments使用数组方法了。</p>
<p>// 用于apply方法<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">myfunction.apply(obj, arguments).</div><div class="line"></div><div class="line">// 使用与另一个数组合并</div><div class="line">Array.prototype.concat.apply([1,2,3], arguments)</div><div class="line">要让arguments对象使用数组方法，真正的解决方法是将arguments转为真正的数组。下面是两种常用的转换方法：slice方法和逐一填入新数组。</div><div class="line"></div><div class="line">var args = Array.prototype.slice.call(arguments);</div><div class="line"></div><div class="line">// or</div><div class="line"></div><div class="line">var args = [];</div><div class="line"><span class="keyword">for</span> (var i = 0; i &lt; arguments.length; i++) &#123;</div><div class="line">  args.push(arguments[i]);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://RubyCountryside.win/2017/01/10/函数下/" data-id="cixytbaoh0007ewz06m4o70m6" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/01/15/git分支/">git分支</a>
          </li>
        
          <li>
            <a href="/2017/01/12/图片滤镜操作/">图片滤镜操作</a>
          </li>
        
          <li>
            <a href="/2017/01/11/图片画廊/">图片画廊</a>
          </li>
        
          <li>
            <a href="/2017/01/11/函数中/">函数（中）</a>
          </li>
        
          <li>
            <a href="/2017/01/10/函数下/">函数（下）</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 Yu Jing<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>