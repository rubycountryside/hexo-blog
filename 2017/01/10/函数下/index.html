<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>函数（下） | RubyCountryside</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="目录1234567891011121314151617181920212223242526概述  函数的声明  函数的重复声明  圆括号运算符，return语句和递归  第一等公民  函数名的提升  不能在条件语句中声明函数函数的属性和方法  name属性  length属性  toString()函数作用域定义函数内部的变量提升函数本身的作用域参数概述参数的省略默认值传递方式同名参数argum">
<meta property="og:type" content="article">
<meta property="og:title" content="函数（下）">
<meta property="og:url" content="http://RubyCountryside.win/2017/01/10/函数下/index.html">
<meta property="og:site_name" content="RubyCountryside">
<meta property="og:description" content="目录1234567891011121314151617181920212223242526概述  函数的声明  函数的重复声明  圆括号运算符，return语句和递归  第一等公民  函数名的提升  不能在条件语句中声明函数函数的属性和方法  name属性  length属性  toString()函数作用域定义函数内部的变量提升函数本身的作用域参数概述参数的省略默认值传递方式同名参数argum">
<meta property="og:updated_time" content="2017-01-10T16:31:35.374Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="函数（下）">
<meta name="twitter:description" content="目录1234567891011121314151617181920212223242526概述  函数的声明  函数的重复声明  圆括号运算符，return语句和递归  第一等公民  函数名的提升  不能在条件语句中声明函数函数的属性和方法  name属性  length属性  toString()函数作用域定义函数内部的变量提升函数本身的作用域参数概述参数的省略默认值传递方式同名参数argum">
  
    <link rel="alternate" href="/atom.xml" title="RubyCountryside" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">RubyCountryside</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://RubyCountryside.win"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-函数下" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/01/10/函数下/" class="article-date">
  <time datetime="2017-01-10T15:41:15.000Z" itemprop="datePublished">2017-01-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      函数（下）
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">概述</div><div class="line">  函数的声明</div><div class="line">  函数的重复声明</div><div class="line">  圆括号运算符，<span class="built_in">return</span>语句和递归</div><div class="line">  第一等公民</div><div class="line">  函数名的提升</div><div class="line">  不能在条件语句中声明函数</div><div class="line">函数的属性和方法</div><div class="line">  name属性</div><div class="line">  length属性</div><div class="line">  toString()</div><div class="line">函数作用域</div><div class="line">定义</div><div class="line">函数内部的变量提升</div><div class="line">函数本身的作用域</div><div class="line">参数</div><div class="line">概述</div><div class="line">参数的省略</div><div class="line">默认值</div><div class="line">传递方式</div><div class="line">同名参数</div><div class="line">arguments对象</div><div class="line">函数的其他知识点</div><div class="line">闭包</div><div class="line">立即调用的函数表达式（IIFE）</div><div class="line"><span class="built_in">eval</span>命令</div></pre></td></tr></table></figure>
<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><hr>
<h3 id="1-1-函数的声明"><a href="#1-1-函数的声明" class="headerlink" title="1.1 函数的声明"></a>1.1 函数的声明</h3><p>（1）function 命令<br>function命令声明的代码区块，就是一个函数。function命令后面是函数名，函数名后面是一对圆括号，里面是传入函数的参数。函数体放在大括号里面。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> <span class="built_in">print</span>(s) &#123;</div><div class="line">  console.log(s);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面的代码命名了一个print函数，以后使用print()这种形式，就可以调用相应的代码。这叫做函数的声明（Function Declaration）</p>
<h3 id="（2）函数表达式"><a href="#（2）函数表达式" class="headerlink" title="（2）函数表达式"></a>（2）函数表达式</h3><p>除了用function命令声明函数，还可以采用变量赋值的写法<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var <span class="built_in">print</span> = <span class="keyword">function</span>(s) &#123;</div><div class="line">  console.log(s);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>这种写法将一个匿名函数赋值给变量。这时，这个匿名函数又称函数表达式（Function Expression），因为赋值语句的等号右侧只能放表达式。<br>采用函数表达式声明函数时，function命令后面不带有函数名。如果加上函数名，该函数名只在函数体内部有效，在函数体外部无效。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var <span class="built_in">print</span> = <span class="keyword">function</span> <span class="function"><span class="title">x</span></span>()&#123;</div><div class="line">  console.log(typeof x);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">x</div><div class="line">// ReferenceError: x is not defined</div><div class="line"></div><div class="line"><span class="built_in">print</span>()</div><div class="line">// <span class="keyword">function</span></div></pre></td></tr></table></figure></p>
<p>上面代码在函数表达式中，加入了函数名x。这个x只在函数体内部可用，指代函数表达式本身，其他地方都不可用。这种写法的用处有两个，一是可以在函数体内部调用自身，二是方便除错（除错工具显示函数调用栈时，将显示函数名，而不再显示这里是一个匿名函数）。因此，下面的形式声明函数也非常常见。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var f = <span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;&#125;;</div></pre></td></tr></table></figure></p>
<p>（3）Function构造函数</p>
<p>还有第三种声明函数的方式：Function构造函数。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var add = new Function(</div><div class="line">  <span class="string">'x'</span>,</div><div class="line">  <span class="string">'y'</span>,</div><div class="line">  <span class="string">'return x + y'</span></div><div class="line">);</div><div class="line"></div><div class="line">// 等同于</div><div class="line"></div><div class="line"><span class="keyword">function</span> add(x, y) &#123;</div><div class="line">  <span class="built_in">return</span> x + y;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="1-2-函数名的提升"><a href="#1-2-函数名的提升" class="headerlink" title="1.2 函数名的提升"></a>1.2 函数名的提升</h3><p>JavaScript引擎将函数名视同变量名，所以采用function命令声明函数时，整个函数会像变量声明一样，被提升到代码头部。所以，下面的代码不会报错。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">f();</div><div class="line"></div><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;&#125;</div></pre></td></tr></table></figure></p>
<p>表面上，上面代码好像在声明之前就调用了函数f。但是实际上，由于“变量提升”，函数f被提升到了代码头部，也就是在调用之前已经声明了。但是，如果采用赋值语句定义函数，JavaScript就会报错。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">f();</div><div class="line">var f = <span class="function"><span class="title">function</span></span> ()&#123;&#125;;</div><div class="line">// TypeError: undefined is not a <span class="keyword">function</span></div></pre></td></tr></table></figure></p>
<p>上面的代码等同于下面的形式。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var f;</div><div class="line">f();</div><div class="line">f = <span class="function"><span class="title">function</span></span> () &#123;&#125;;</div></pre></td></tr></table></figure></p>
<p>上面代码第二行，调用f的时候，f只是被声明了，还没有被赋值，等于undefined，所以会报错。因此，如果同时采用function命令和赋值语句声明同一个函数，最后总是采用赋值语句的定义。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var f = <span class="function"><span class="title">function</span></span>() &#123;</div><div class="line">  console.log(<span class="string">'1'</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;</div><div class="line">  console.log(<span class="string">'2'</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">f() // 1</div></pre></td></tr></table></figure></p>
<p>不能在条件语句中声明函数</p>
<p>根据ECMAScript的规范，不得在非函数的代码块中声明函数，最常见的情况就是if和try语句。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (foo) &#123;</div><div class="line">  <span class="keyword">function</span> <span class="function"><span class="title">x</span></span>() &#123;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">try &#123;</div><div class="line">  <span class="keyword">function</span> <span class="function"><span class="title">x</span></span>() &#123;&#125;</div><div class="line">&#125; catch(e) &#123;</div><div class="line">  console.log(e);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面代码分别在if代码块和try代码块中声明了两个函数，按照语言规范，这是不合法的。但是，实际情况是各家浏览器往往并不报错，能够运行。</p>
<p>但是由于存在函数名的提升，所以在条件语句中声明函数，可能是无效的，这是非常容易出错的地方。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (<span class="literal">false</span>) &#123;</div><div class="line">  <span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">f() // 不报错</div></pre></td></tr></table></figure></p>
<p>上面代码的原始意图是不声明函数f，但是由于f的提升，导致if语句无效，所以上面的代码不会报错。要达到在条件语句中定义函数的目的，只有使用函数表达式。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (<span class="literal">false</span>) &#123;</div><div class="line">  var f = <span class="function"><span class="title">function</span></span> () &#123;&#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">f() // undefined</div></pre></td></tr></table></figure></p>
<p>函数的属性和方法<br>name属性</p>
<p>name属性返回紧跟在function关键字之后的那个函数名。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">f1</span></span>() &#123;&#125;</div><div class="line">f1.name // <span class="string">'f1'</span></div><div class="line"></div><div class="line">var f2 = <span class="function"><span class="title">function</span></span> () &#123;&#125;;</div><div class="line">f2.name // <span class="string">''</span></div><div class="line"></div><div class="line">var f3 = <span class="keyword">function</span> <span class="function"><span class="title">myName</span></span>() &#123;&#125;;</div><div class="line">f3.name // <span class="string">'myName'</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，函数的name属性总是返回紧跟在function关键字之后的那个函数名。对于f2来说，返回空字符串，匿名函数的name属性总是为空字符串；对于f3来说，返回函数表达式的名字（真正的函数名还是f3，myName这个名字只在函数体内部可用）。</p>
<p>length属性</p>
<p>length属性返回函数预期传入的参数个数，即函数定义之中的参数个数。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> f(a, b) &#123;&#125;</div><div class="line">f.length // 2</div></pre></td></tr></table></figure></p>
<p>上面代码定义了空函数f，它的length属性就是定义时的参数个数。不管调用时输入了多少个参数，length属性始终等于2。</p>
<p>length属性提供了一种机制，判断定义时和调用时参数的差异，以便实现面向对象编程的”方法重载“（overload）。</p>
<p>toString()</p>
<p>函数的toString方法返回函数的源码。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;</div><div class="line">  a();</div><div class="line">  b();</div><div class="line">  c();</div><div class="line">&#125;</div><div class="line"></div><div class="line">f.toString()</div><div class="line">// <span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;</div><div class="line">//  a();</div><div class="line">//  b();</div><div class="line">//  c();</div><div class="line">// &#125;</div><div class="line">函数内部的注释也可以返回。</div><div class="line"></div><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;/*</div><div class="line">  这是一个</div><div class="line">  多行注释</div><div class="line">*/&#125;</div><div class="line"></div><div class="line">f.toString()</div><div class="line">// <span class="string">"function f()&#123;/*</span></div><div class="line">//   这是一个</div><div class="line">//   多行注释</div><div class="line">// */&#125;"</div><div class="line">利用这一点，可以变相实现多行字符串。</div><div class="line"></div><div class="line">var multiline = <span class="keyword">function</span> (fn) &#123;</div><div class="line">  var arr = fn.toString().split(<span class="string">'\n'</span>);</div><div class="line">  <span class="built_in">return</span> arr.slice(1, arr.length - 1).join(<span class="string">'\n'</span>);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;/*</div><div class="line">  这是一个</div><div class="line">  多行注释</div><div class="line">*/&#125;</div><div class="line"></div><div class="line">multiline(f);</div><div class="line">// <span class="string">" 这是一个</span></div><div class="line">//   多行注释"</div></pre></td></tr></table></figure></p>
<p>函数作用域<br>定义</p>
<p>作用域（scope）指的是变量存在的范围。Javascript只有两种作用域：一种是全局作用域，变量在整个程序中一直存在，所有地方都可以读取；另一种是函数作用域，变量只在函数内部存在。</p>
<p>在函数外部声明的变量就是全局变量（global variable），它可以在函数内部读取。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var v = 1;</div><div class="line"></div><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">f</span></span>()&#123;</div><div class="line">  console.log(v);</div><div class="line">&#125;</div><div class="line"></div><div class="line">f()</div><div class="line">// 1</div></pre></td></tr></table></figure></p>
<p>上面的代码表明，函数f内部可以读取全局变量v。</p>
<p>在函数内部定义的变量，外部无法读取，称为“局部变量”（local variable）。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">f</span></span>()&#123;</div><div class="line">  var v = 1;</div><div class="line">&#125;</div><div class="line"></div><div class="line">v // ReferenceError: v is not defined</div></pre></td></tr></table></figure></p>
<p>上面代码中，变量v在函数内部定义，所以是一个局部变量，函数之外就无法读取。</p>
<p>函数内部定义的变量，会在该作用域内覆盖同名全局变量。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var v = 1;</div><div class="line"></div><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">f</span></span>()&#123;</div><div class="line">  var v = 2;</div><div class="line">  console.log(v);</div><div class="line">&#125;</div><div class="line"></div><div class="line">f() // 2</div><div class="line">v // 1</div></pre></td></tr></table></figure></p>
<p>上面代码中，变量v同时在函数的外部和内部有定义。结果，在函数内部定义，局部变量v覆盖了全局变量v。</p>
<p>注意，对于var命令来说，局部变量只能在函数内部声明，在其他区块中声明，一律都是全局变量。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</div><div class="line">  var x = 5;</div><div class="line">&#125;</div><div class="line">console.log(x);  // 5</div></pre></td></tr></table></figure></p>
<p>上面代码中，变量x在条件判断区块之中声明，结果就是一个全局变量，可以在区块之外读取。</p>
<p>函数内部的变量提升</p>
<p>与全局作用域一样，函数作用域内部也会产生“变量提升”现象。var命令声明的变量，不管在什么位置，变量声明都会被提升到函数体的头部。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> foo(x) &#123;</div><div class="line">  <span class="keyword">if</span> (x &gt; 100) &#123;</div><div class="line">    var tmp = x - 100;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">上面的代码等同于</div><div class="line"></div><div class="line"><span class="keyword">function</span> foo(x) &#123;</div><div class="line">  var tmp;</div><div class="line">  <span class="keyword">if</span> (x &gt; 100) &#123;</div><div class="line">    tmp = x - 100;</div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>函数本身的作用域</p>
<p>函数本身也是一个值，也有自己的作用域。它的作用域与变量一样，就是其声明时所在的作用域，与其运行时所在的作用域无关。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var a = 1;</div><div class="line">var x = <span class="function"><span class="title">function</span></span> () &#123;</div><div class="line">  console.log(a);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;</div><div class="line">  var a = 2;</div><div class="line">  x();</div><div class="line">&#125;</div><div class="line"></div><div class="line">f() // 1</div></pre></td></tr></table></figure></p>
<p>上面代码中，函数x是在函数f的外部声明的，所以它的作用域绑定外层，内部变量a不会到函数f体内取值，所以输出1，而不是2。</p>
<p>总之，函数执行时所在的作用域，是定义时的作用域，而不是调用时所在的作用域。</p>
<p>很容易犯错的一点是，如果函数A调用函数B，却没考虑到函数B不会引用函数A的内部变量。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var x = <span class="function"><span class="title">function</span></span> () &#123;</div><div class="line">  console.log(a);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">function</span> y(f) &#123;</div><div class="line">  var a = 2;</div><div class="line">  f();</div><div class="line">&#125;</div><div class="line"></div><div class="line">y(x)</div><div class="line">// ReferenceError: a is not defined</div></pre></td></tr></table></figure></p>
<p>上面代码将函数x作为参数，传入函数y。但是，函数x是在函数y体外声明的，作用域绑定外层，因此找不到函数y的内部变量a，导致报错。</p>
<p>同样的，函数体内部声明的函数，作用域绑定函数体内部。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">foo</span></span>() &#123;</div><div class="line">  var x = 1;</div><div class="line">  <span class="keyword">function</span> <span class="function"><span class="title">bar</span></span>() &#123;</div><div class="line">    console.log(x);</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">return</span> bar;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var x = 2;</div><div class="line">var f = foo();</div><div class="line">f() // 1</div></pre></td></tr></table></figure></p>
<p>上面代码中，函数foo内部声明了一个函数bar，bar的作用域绑定foo。当我们在foo外部取出bar执行时，变量x指向的是foo内部的x，而不是foo外部的x。正是这种机制，构成了下文要讲解的“闭包”现象。</p>
<p>参数<br>概述</p>
<p>函数运行的时候，有时需要提供外部数据，不同的外部数据会得到不同的结果，这种外部数据就叫参数。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> square(x) &#123;</div><div class="line">  <span class="built_in">return</span> x * x;</div><div class="line">&#125;</div><div class="line"></div><div class="line">square(2) // 4</div><div class="line">square(3) // 9</div></pre></td></tr></table></figure></p>
<p>上式的x就是square函数的参数。每次运行的时候，需要提供这个值，否则得不到结果。</p>
<p>参数的省略</p>
<p>函数参数不是必需的，Javascript允许省略参数。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> f(a, b) &#123;</div><div class="line">  <span class="built_in">return</span> a;</div><div class="line">&#125;</div><div class="line"></div><div class="line">f(1, 2, 3) // 1</div><div class="line">f(1) // 1</div><div class="line">f() // undefined</div><div class="line"></div><div class="line">f.length // 2</div></pre></td></tr></table></figure></p>
<p>上面代码的函数f定义了两个参数，但是运行时无论提供多少个参数（或者不提供参数），JavaScript都不会报错。</p>
<p>被省略的参数的值就变为undefined。需要注意的是，函数的length属性与实际传入的参数个数无关，只反映函数预期传入的参数个数。</p>
<p>但是，没有办法只省略靠前的参数，而保留靠后的参数。如果一定要省略靠前的参数，只有显式传入undefined。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> f(a, b) &#123;</div><div class="line">  <span class="built_in">return</span> a;</div><div class="line">&#125;</div><div class="line"></div><div class="line">f( , 1) // SyntaxError: Unexpected token ,(…)</div><div class="line">f(undefined, 1) // undefined</div></pre></td></tr></table></figure></p>
<p>上面代码中，如果省略第一个参数，就会报错。</p>
<p>默认值</p>
<p>通过下面的方法，可以为函数的参数设置默认值。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> f(a)&#123;</div><div class="line">  a = a || 1;</div><div class="line">  <span class="built_in">return</span> a;</div><div class="line">&#125;</div><div class="line"></div><div class="line">f(<span class="string">''</span>) // 1</div><div class="line">f(0) // 1</div></pre></td></tr></table></figure></p>
<p>上面代码的||表示“或运算”，即如果a有值，则返回a，否则返回事先设定的默认值（上例为1）。</p>
<p>这种写法会对a进行一次布尔运算，只有为true时，才会返回a。可是，除了undefined以外，0、空字符、null等的布尔值也是false。也就是说，在上面的函数中，不能让a等于0或空字符串，否则在明明有参数的情况下，也会返回默认值。</p>
<p>为了避免这个问题，可以采用下面更精确的写法。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> f(a) &#123;</div><div class="line">  (a !== undefined &amp;&amp; a !== null) ? a = a : a = 1;</div><div class="line">  <span class="built_in">return</span> a;</div><div class="line">&#125;</div><div class="line"></div><div class="line">f() // 1</div><div class="line">f(<span class="string">''</span>) // <span class="string">""</span></div><div class="line">f(0) // 0</div></pre></td></tr></table></figure></p>
<p>上面代码中，函数f的参数是空字符或0，都不会触发参数的默认值。</p>
<p>传递方式</p>
<p>函数参数如果是原始类型的值（数值、字符串、布尔值），传递方式是传值传递（passes by value）。这意味着，在函数体内修改参数值，不会影响到函数外部。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var p = 2;</div><div class="line"></div><div class="line"><span class="keyword">function</span> f(p) &#123;</div><div class="line">  p = 3;</div><div class="line">&#125;</div><div class="line">f(p);</div><div class="line"></div><div class="line">p // 2</div></pre></td></tr></table></figure></p>
<p>上面代码中，变量p是一个原始类型的值，传入函数f的方式是传值传递。因此，在函数内部，p的值是原始值的拷贝，无论怎么修改，都不会影响到原始值。</p>
<p>但是，如果函数参数是复合类型的值（数组、对象、其他函数），传递方式是传址传递（pass by reference）。也就是说，传入函数的原始值的地址，因此在函数内部修改参数，将会影响到原始值。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var obj = &#123;p: 1&#125;;</div><div class="line"></div><div class="line"><span class="keyword">function</span> f(o) &#123;</div><div class="line">  o.p = 2;</div><div class="line">&#125;</div><div class="line">f(obj);</div><div class="line"></div><div class="line">obj.p // 2</div></pre></td></tr></table></figure></p>
<p>上面代码中，传入函数f的是参数对象obj的地址。因此，在函数内部修改obj的属性p，会影响到原始值。</p>
<p>注意，如果函数内部修改的，不是参数对象的某个属性，而是替换掉整个参数，这时不会影响到原始值。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var obj = [1, 2, 3];</div><div class="line"></div><div class="line"><span class="keyword">function</span> f(o)&#123;</div><div class="line">  o = [2, 3, 4];</div><div class="line">&#125;</div><div class="line">f(obj);</div><div class="line"></div><div class="line">obj // [1, 2, 3]</div></pre></td></tr></table></figure></p>
<p>上面代码中，在函数f内部，参数对象obj被整个替换成另一个值。这时不会影响到原始值。这是因为，形式参数（o）与实际参数obj存在一个赋值关系。</p>
<p>// 函数f内部<br>o = obj;<br>上面代码中，对o的修改都会反映在obj身上。但是，如果对o赋予一个新的值，就等于切断了o与obj的联系，导致此后的修改都不会影响到obj了。</p>
<p>某些情况下，如果需要对某个原始类型的变量，获取传址传递的效果，可以将它写成全局对象的属性。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var a = 1;</div><div class="line"></div><div class="line"><span class="keyword">function</span> f(p) &#123;</div><div class="line">  window[p] = 2;</div><div class="line">&#125;</div><div class="line">f(<span class="string">'a'</span>);</div><div class="line"></div><div class="line">a // 2</div></pre></td></tr></table></figure></p>
<p>上面代码中，变量a本来是传值传递，但是写成window对象的属性，就达到了传址传递的效果。</p>
<p>同名参数</p>
<p>如果有同名的参数，则取最后出现的那个值。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> f(a, a) &#123;</div><div class="line">  console.log(a);</div><div class="line">&#125;</div><div class="line"></div><div class="line">f(1, 2) // 2</div></pre></td></tr></table></figure></p>
<p>上面的函数f有两个参数，且参数名都是a。取值的时候，以后面的a为准。即使后面的a没有值或被省略，也是以其为准。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> f(a, a)&#123;</div><div class="line">  console.log(a);</div><div class="line">&#125;</div><div class="line"></div><div class="line">f(1) // undefined</div></pre></td></tr></table></figure></p>
<p>调用函数f的时候，没有提供第二个参数，a的取值就变成了undefined。这时，如果要获得第一个a的值，可以使用arguments对象。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> f(a, a)&#123;</div><div class="line">  console.log(arguments[0]);</div><div class="line">&#125;</div><div class="line"></div><div class="line">f(1) // 1</div></pre></td></tr></table></figure></p>
<p>arguments对象</p>
<p>（1）定义</p>
<p>由于JavaScript允许函数有不定数目的参数，所以我们需要一种机制，可以在函数体内部读取所有参数。这就是arguments对象的由来。</p>
<p>arguments对象包含了函数运行时的所有参数，arguments[0]就是第一个参数，arguments[1]就是第二个参数，以此类推。这个对象只有在函数体内部，才可以使用。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">var f = <span class="keyword">function</span>(one) &#123;</div><div class="line">  console.log(arguments[0]);</div><div class="line">  console.log(arguments[1]);</div><div class="line">  console.log(arguments[2]);</div><div class="line">&#125;</div><div class="line"></div><div class="line">f(1, 2, 3)</div><div class="line">// 1</div><div class="line">// 2</div><div class="line">// 3</div><div class="line">arguments对象除了可以读取参数，还可以为参数赋值（严格模式不允许这种用法）。</div><div class="line"></div><div class="line">var f = <span class="keyword">function</span>(a, b) &#123;</div><div class="line">  arguments[0] = 3;</div><div class="line">  arguments[1] = 2;</div><div class="line">  <span class="built_in">return</span> a + b;</div><div class="line">&#125;</div><div class="line"></div><div class="line">f(1, 1)</div><div class="line">// 5</div><div class="line">可以通过arguments对象的length属性，判断函数调用时到底带几个参数。</div><div class="line"></div><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;</div><div class="line">  <span class="built_in">return</span> arguments.length;</div><div class="line">&#125;</div><div class="line"></div><div class="line">f(1, 2, 3) // 3</div><div class="line">f(1) // 1</div><div class="line">f() // 0</div></pre></td></tr></table></figure></p>
<p>（2）与数组的关系</p>
<p>需要注意的是，虽然arguments很像数组，但它是一个对象。数组专有的方法（比如slice和forEach），不能在arguments对象上直接使用。</p>
<p>但是，可以通过apply方法，把arguments作为参数传进去，这样就可以让arguments使用数组方法了。</p>
<p>// 用于apply方法<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">myfunction.apply(obj, arguments).</div><div class="line"></div><div class="line">// 使用与另一个数组合并</div><div class="line">Array.prototype.concat.apply([1,2,3], arguments)</div><div class="line">要让arguments对象使用数组方法，真正的解决方法是将arguments转为真正的数组。下面是两种常用的转换方法：slice方法和逐一填入新数组。</div><div class="line"></div><div class="line">var args = Array.prototype.slice.call(arguments);</div><div class="line"></div><div class="line">// or</div><div class="line"></div><div class="line">var args = [];</div><div class="line"><span class="keyword">for</span> (var i = 0; i &lt; arguments.length; i++) &#123;</div><div class="line">  args.push(arguments[i]);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://RubyCountryside.win/2017/01/10/函数下/" data-id="cixyt408o0004zgkxjy09zgxu" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2017/01/11/函数中/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          函数（中）
        
      </div>
    </a>
  
  
    <a href="/2017/01/09/Linux软件安装包类型/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Linux软件安装包类型</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/01/15/jian/">jian</a>
          </li>
        
          <li>
            <a href="/2017/01/12/图片滤镜操作/">图片滤镜操作</a>
          </li>
        
          <li>
            <a href="/2017/01/11/图片画廊/">图片画廊</a>
          </li>
        
          <li>
            <a href="/2017/01/11/函数中/">函数（中）</a>
          </li>
        
          <li>
            <a href="/2017/01/10/函数下/">函数（下）</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 Yu Jing<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>